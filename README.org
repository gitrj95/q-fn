#+title:q-fn
#+author:rj

* motivation
- there exist repeated, higher-order idioms that are not trivially derived from
  stock adverbs
  - eg computing the arity of a function is surprisingly complicated in q to solve in
    a general sense
  - eg it is tricky to dynamically construct projections
- the ability to treat a sequence of functions as a deque that behaves
  as a single composite on application is useful
- dynamic typing can be undesirable in cases whereby the grammar is well-defined
  but does not follow the desired semantics
  - eg want to declare that a function only accepts arguments of a certain type
  - eg want to be able to switch on type and apply matching functions
- cascading where semantics, akin to those in qsql, are useful generally
* interface
** functions
| name       | description                                                                                                                         |
|------------+-------------------------------------------------------------------------------------------------------------------------------------|
| .fn.rnk    | determines the rank (arity) of a function given a function                                                                          |
| .fn.proj   | constructs a projection given a function, indices, and arguments                                                                    |
| .fn.projwr | constructs a projection given a function, its rank, indices, and arguments                                                          |
| .fn.enqf   | enqueues a unary function to the front of a unary function given a destination and source                                           |
| .fn.enqb   | enqueues a unary function to the back of a unary function given a destination and source                                            |
| .fn.empf   | emplaces a unary function to the front of a unary function given a destination name and source                                      |
| .fn.empb   | emplaces a unary function to the back of a unary function given a destination name and source                                       |
| .fn.ty     | computes the recursive type given arbitrary k data                                                                                  |
| .fn.td     | defines a typed function given a function and a type list                                                                           |
| .fn.ts     | switch an argument on type and apply the first match given a function list, type list list, and argument list                       |
| .fn.tswf   | switch an argument on type and apply all matches given a function list, type list list, and argument list                           |
| .fn.wa     | finds the indices where a set of masks all hold true against a list given a set of mask functions and target list                   |
| .fn.atwa   | reduces a list to the elements whereby a set of masks all hold true given a set of mask functions and target list                   |
| .fn.wo     | finds the indices where a set of masks hold true for at least one mask given a set of mask functions and target list                |
| .fn.atwo   | reduces a list to the elements whereby a set of masks hold true for at least one mask given a set of mask functions and target list |
* examples
#+begin_example
q)/ .fn.rnk takes a [<function>]
q).fn.rnk{z}
3

q)/ it deals with composites and projections
q).fn.rnk['[upper;string]]
1
q).fn.rnk[upper string@]
1

q)/ it disambiguates between elisions and (::) literals
q).fn.rnk[{(y;z)}[;::]]
2
q).fn.rnk[{(y;z)}[;]]
3

q)/ it assigns the arity of enlist to 0N, by convention
q).fn.rnk[enlist]
0N
q)enlist[1;2;3]
1 2 3
q)enlist[1;2;3;4;5]
1 2 3 4 5
q)/ clearly, its arity is undefined

q)/ adverbs are of no concern
q).fn.rnk[{z}[;;::]/]
1
q).fn.rnk[+':]
2
#+end_example
#+begin_example
q)/ .fn.proj takes a [<function>;<indices>;<arguments>]
q).fn.proj[{z};0 2;10 11]
{z}[10;;11]

q)/ .fn.projwr takes a [<function>;<rank>;<indices>;<arguments>]
q)/ specifying rank obviates the need for run-time reflection
q).fn.projwr[{z};3;0 2;10 11]
{z}[10;;11]

q)/ .fn.enqf and .fn.enqb take a [<unary>;<unary>]
q)/ the "back" of a function executes first, ie .fn.enqb[f(g(x));h(x)] -> f(g(h(x)))
q)/ why not '[...]? compose does not check arity on its own. we want the deque
q)/ to execute wholly
q).fn.enqb/[(string;last;first)](1 2;3 4)
,"2"

q)/ .fn.empf and .fn.empb take a [<symbol>;<symbol>|<function>]
q)/ .fn.empf and .fn.empb behave like their enqueue analogs, but they mutate the
q)/ destination in-place
q)x:upper;.fn.empb[`x;string]
`x
q)x`hello
"HELLO"
#+end_example
#+begin_example
q)/ .fn.ty takes a [<any>]
q)/ it returns its "recursive type" as used by other functions in this library
q).fn.ty[(4;1.;`a`b`c;(();()))]
-7h
-9h
11h
(();())
q)/ we recursively resolve all mixed lists to their typed constituents--except
q)/ (), which remains the same

q)/ .fn.td takes a [<function>;<ty tree>]
q)/ it mints a function that will fail with 'type if the argument fails to meet
q)/ the <ty tree>
q)f:.fn.td[+;-9 7h]
q)f[1.;til 10]
1 2 3 4 5 6 7 8 9 10f
q)f[1;til 10]
'type

q)/ if you're unsure what the <ty tree> is, just supply a sample argument list
q)/ to .fn.ty
q)g:.fn.td[{$[x>0;2*y;neg z]};.fn.ty(10;.z.p;-7)]
q)g[1;"p"$2021.01.01;2]
2042.01.02D00:00:00.000000000

q)/ unary functions minted with .fn.td, of course, may be enqueued or emplaced
q).fn.enqb[max;.fn.td[{where 0=mod[x;2]};99h]]17 8 9!0 1 2
17

q)/ .fn.ts takes a [<function list>;<ty tree list>;<argument list>]
q).fn.ts[({10};{11};{12});enlist each -7 -9 -7h;enlist 1]
10
q)/ notice how only the 1st function is applied

q)/ no matches is equivalent to a blank statement 
q).fn.ts[({10};{11};{12});enlist each -9 -9 -9h;enlist 1]
q)

q)/ .fn.tswf behaves like .fn.ts, but it applies all matched functions
q).fn.tswf[({10};{11};{12});enlist each -7 -9 -7h;enlist 1]
10 12
#+end_example
#+begin_example
q)/ .fn.wa takes a [<masks>;<list>], st <mask> := function that returns a boolean
q)/ list of the same arity as <list>
q)/ it returns the indices where all masks hold true
q).fn.wa[(0=mod[;2]@;0=mod[;3]@;0=mod[;17]@);102 103 408 6 28]
0 2

q)/ .fn.wo takes the same arguments and has the same <mask> definition, but it
q)/ returns the indices where at least one mask holds true
q).fn.wo[(0=mod[;2]@;0=mod[;3]@;0=mod[;17]@);102 103 408 6 28]
0 2 3 4

q)/ .fn.atwa takes the same arguments and has the same <mask> definition, but it
q)/ indexes <list> by the results wa would produce
q).fn.atwa[(0=mod[;2]@;0=mod[;3]@;0=mod[;17]@);102 103 408 6 28]
102 408

q)/ and likewise for .fn.atwo wrt .fn.wo
q).fn.atwo[(0=mod[;2]@;0=mod[;3]@;0=mod[;17]@);102 103 408 6 28]
102 408 6 28
#+end_example
* pitfalls
#+begin_example
q)/ the completeness of .fn.rnk comes at the cost of pricey scoping gynmastics.
q)/ to my knowledge, there is no other way to generally compute arity by
q)/ reflection in q. ergo, try to move the cost from run-time to "compile"-time
q)/ for .fn.rnk, .fn.enq[fb], .fn.emp[fb], and .fn.td--where possible

q)/ wrt .fn.proj, if you know the rank at "compile"-time, there is no reason to
q)/ use .fn.proj; use .fn.projwr
#+end_example
