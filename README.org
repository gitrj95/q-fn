#+title:q-fn
#+author:rj

* motivation
- there exist repeated, higher-order idioms that are not trivially derived from
  stock adverbs
  - eg computing the arity of a function is surprisingly complicated in q to solve in
    a general sense
  - eg it is tricky to dynamically construct projections
- the ability to treat a sequence of functions as a deque that behaves
  as a single composite on application is useful
- dynamic typing can be undesirable in cases whereby the grammar is well-defined
  but does not follow the desired semantics
  - eg want to declare that a function only accepts arguments of a certain type
  - eg want to be able to switch on type and apply matching functions
- cascading where semantics, akin to those in qsql, are useful generally
* interface
** functions
| name       | description                                                                                                          |
|------------+----------------------------------------------------------------------------------------------------------------------|
| .fn.rnk    | determines the rank (arity) of a function given a function                                                           |
| .fn.proj   | constructs a projection given a function, indices, and arguments                                                     |
| .fn.projwr | constructs a projection given a function, its rank, indices, and arguments                                           |
| .fn.enqf   | enqueues a unary function to the front of a unary function given a destination and source                            |
| .fn.enqb   | enqueues a unary function to the back of a unary function given a destination and source                             |
| .fn.empf   | emplaces a unary function to the front of a unary function given a destination name and source                       |
| .fn.empb   | emplaces a unary function to the back of a unary function given a destination name and source                        |
| .fn.ty     | computes the recursive type given arbitrary k data                                                                   |
| .fn.td     | defines a typed function given a function and a type list                                                            |
| .fn.ts     | switch an argument on type and apply the first match given a function list, type list list, and argument list        |
| .fn.tswf   | switch an argument on type and apply all matches given a function list, type list list, and argument list            |
| .fn.wa     | finds the indices where a set of masks all hold true against a list given a set of mask functions and target list    |
| .fn.pwa    | like .fn.wa but allocates threads to each mask application                                                           |
| .fn.wa1    | like .fn.wa but uses a different algorithm that favors expensive or many masks                                       |
| .fn.wo     | finds the indices where a set of masks hold true for at least one mask given a set of mask functions and target list |
| .fn.pwo    | like .fn.wo but allocates threads to each mask application                                                           |
| .fn.wo1    | like .fn.wo but uses a different algorithm that favors expensive or many masks                                       |
* examples
#+begin_example
q)/ .fn.rnk takes a [<function>]
q).fn.rnk{z}
3

q)/ it deals with composites and projections
q).fn.rnk['[upper;string]]
1
q).fn.rnk[upper string@]
1

q)/ it disambiguates between elisions and (::) literals
q).fn.rnk[{(y;z)}[;::]]
2
q).fn.rnk[{(y;z)}[;]]
3

q)/ it assigns the arity of enlist to 0N, by convention
q).fn.rnk[enlist]
0N
q)enlist[1;2;3]
1 2 3
q)enlist[1;2;3;4;5]
1 2 3 4 5
q)/ clearly, its arity is undefined

q)/ adverbs are of no concern
q).fn.rnk[{z}[;;::]/]
1
q).fn.rnk[+':]
2
#+end_example
#+begin_example
q)/ .fn.proj takes a [<function>;<indices>;<arguments>]
q).fn.proj[{z};0 2;10 11]
{z}[10;;11]

q)/ .fn.projwr takes a [<function>;<rank>;<indices>;<arguments>]
q)/ specifying rank obviates the need for run-time reflection
q).fn.projwr[{z};3;0 2;10 11]
{z}[10;;11]

q)/ .fn.enqf and .fn.enqb take a [<unary>;<unary>]
q)/ the "back" of a function executes first, ie .fn.enqb[f(g(x));h(x)] -> f(g(h(x)))
q)/ why not '[...]? compose does not check arity on its own. we want the deque
q)/ to execute wholly
q).fn.enqb/[(string;last;first)](1 2;3 4)
,"2"

q)/ .fn.empf and .fn.empb take a [<symbol>;<symbol>|<function>]
q)/ .fn.empf and .fn.empb behave like their enqueue analogs, but they mutate the
q)/ destination in-place
q)x:upper;.fn.empb[`x;string]
`x
q)x`hello
"HELLO"
#+end_example
#+begin_example
q)/ .fn.ty takes a [<any>]
q)/ it returns its "recursive type" as used by other functions in this library
q).fn.ty[(4;1.;`a`b`c;(();()))]
-7h
-9h
11h
(();())
q)/ we recursively resolve all mixed lists to their typed constituents--except
q)/ (), which remains the same

q)/ .fn.td takes a [<function>;<ty tree>]
q)/ it mints a function that will fail with 'type if the argument fails to meet
q)/ the <ty tree>
q)f:.fn.td[+;-9 7h]
q)f[1.;til 10]
1 2 3 4 5 6 7 8 9 10f
q)f[1;til 10]
'type

q)/ if you're unsure what the <ty tree> is, just supply a sample argument list
q)/ to .fn.ty
q)g:.fn.td[{$[x>0;2*y;neg z]};.fn.ty(10;.z.p;-7)]
q)g[1;"p"$2021.01.01;2]
2042.01.02D00:00:00.000000000

q)/ unary functions minted with .fn.td, of course, may be enqueued or emplaced
q).fn.enqb[max;.fn.td[{where 0=mod[x;2]};99h]]17 8 9!0 1 2
17

q)/ .fn.ts takes a [<function list>;<ty tree list>;<argument list>]
q).fn.ts[({10};{11};{12});enlist each -7 -9 -7h;enlist 1]
10
q)/ notice how only the 1st function is applied

q)/ no matches is equivalent to a blank statement 
q).fn.ts[({10};{11};{12});enlist each -9 -9 -9h;enlist 1]
q)

q)/ .fn.tswf behaves like .fn.ts, but it applies all matched functions
q).fn.tswf[({10};{11};{12});enlist each -7 -9 -7h;enlist 1]
10 12
#+end_example
#+begin_example
q)/ .fn.wa takes a [<masks>;<list>], st <mask> := function that returns a boolean
q)/ vector of the same size as <list>
q)/ it returns the indices where all masks hold true
q).fn.wa[(0=mod[;2]@;0=mod[;3]@;0=mod[;17]@);102 103 408 6 28]
0 2
q)/ .fn.pwa and .fn.wa1 behaves semantically identically. their use is described
q)/ later
q).fn.pwa[(0=mod[;2]@;0=mod[;3]@;0=mod[;17]@);102 103 408 6 28]
0 2
q).fn.wa1[(0=mod[;2]@;0=mod[;3]@;0=mod[;17]@);102 103 408 6 28]
0 2

q)/ .fn.wo takes the same arguments and has the same <mask> definition, but it
q)/ returns the indices where at least one mask holds true
q).fn.wo[(0=mod[;2]@;0=mod[;3]@;0=mod[;17]@);102 103 408 6 28]
0 2 3 4
q)/ likewise for .fn.pwo and .fn.wo1
q).fn.pwo[(0=mod[;2]@;0=mod[;3]@;0=mod[;17]@);102 103 408 6 28]
0 2 3 4
q).fn.wo1[(0=mod[;2]@;0=mod[;3]@;0=mod[;17]@);102 103 408 6 28]
0 2 3 4

q)/ .fn.wa and .fn.wb naively apply each mask serially and reduce the conforming
q)/ boolean vectors, .fn.pwa and .fn.pwb apply each mask in parallel and reduce,
q)/ and .fn.wa1 and .fn.wo1 apply the (i+1)th mask only where prudent. eg, if
q)/ mask i is false at index 2, and you're reducing with and, there's no need to
q)/ compute mask i+1, ... at index 2. this seems straightforward, but q's native
q)/ simd acceleration and cache treatment can allow primitives with o(n) behavior
q)/ to function as if they were constant time. the naive approaches in .fn.wa and
q)/ .fn.wb are therefore the fastest for relatively trivial masks, but you should
q)/ always measure
q)\s
16i
q)f:(0=mod[;2]@;0=mod[;3]@);x:1000000?10000000
q)\t:100 .fn.wa[f;x] / 1st
268
q)\t:100 .fn.pwa[f;x] / 3rd
396
q)\t:100 .fn.wa1[f;x] / 2nd
311
q)f:({","~'first each string 17.2<sqrt(x*x div 2)xexp 1.5};0=mod[;6]@)
q)\t:100 .fn.wa[f;x] / 2nd
5710
q)\t:100 .fn.pwa[f;x] / 3rd
8678
q)\t:100 .fn.wa1[f;x] / 1st
5594
q)f:.fn.proj[{0=x mod y};1]each til 100
q)\t:10 .fn.wa[f;x] / 2nd
1233
q)\t:10 .fn.pwa[f;x] / 3rd
8672
q)\t:10 .fn.wa1[f;x] / 1st
148
#+end_example
* pitfalls
#+begin_example
q)/ the completeness of .fn.rnk comes at the cost of pricey scoping gymnastics.
q)/ to my knowledge, there is no other way to generally compute arity by
q)/ reflection in q. ergo, try to move the cost from run-time to "compile"-time,
q)/ unless you're in the debugger
#+end_example
#+begin_example
q)/ wrt .fn.proj, if you know the rank at "compile"-time, there is no reason to
q)/ use .fn.proj; use .fn.projwr
q)f:{z+3*y|x};g:.fn.projwr[f;3;2;100]
#+end_example
#+begin_example
q)/ .fn.pt and .fn.rnkp are not configuration. do not change these!
q).fn.pt:(::)
q).fn.proj[{};0 2;10 11]
11
q)/ nonsense result
#+end_example

