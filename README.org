#+title:q-fn
#+author:rj

* motivation
- there exist repeated, higher-order idioms that are not trivially derived from
  stock adverbs
  - eg computing the arity of a function is surprisingly complicated in q to solve in
    a general sense
  - eg it is tricky to dynamically construct projections 
- the ability to treat a function as a deque that behaves as a single composite
  on application is useful in practice
- dynamic typing can be undesirable in cases whereby semantic errors are not
  evidenced by 'type
  - eg want to declare that a function only accepts arguments of a certain type
  - eg want to be able to switch on type and apply matching functions
- etc
* interface
** functions
| name   | description                                                                                                   |
|--------+---------------------------------------------------------------------------------------------------------------|
| rnk    | determines the rank (arity) of a function given a function                                                    |
| proj   | constructs a projection given a function, indices, and arguments                                              |
| projwr | constructs a projection given a function, its rank, indices, and arguments                                    |
| enqf   | enqueues a function to the front of a function given a destination and source                                 |
| enqb   | enqueues a function to the back of a function given a destination and source                                  |
| empf   | emplaces a function to the front of a function given a destination name and source                            |
| empb   | emplaces a function to the back of a function given a destination name and source                             |
| td     | defines a typed function given a function and a type list                                                     |
| tdws   | defines a typed function given a function and a sample argument list                                          |
| ts     | switch an argument on type and apply the first match given a function list, type list list, and argument list |
| tswf   | switch an argument on type and apply all matches given a function list, type list list, and argument list     |
* examples
#+begin_example
q)/ .fn.rnk takes a [<function>]
q).fn.rnk{z}
3

q)/ it deals with composites and projections
q).fn.rnk['[upper;string]]
1
q).fn.rnk[upper string@]
1

q)/ it disambiguates between elisions and (::) literals
q).fn.rnk[{(y;z)}[;::]]
2
q).fn.rnk[{(y;z)}[;]]
3

q)/ it assigns the undefined arity of enlist to 0N, by convention
q).fn.rnk['[{};enlist]]
0N

q)/ and more
#+end_example
#+begin_example
q)
#+end_example
* pitfalls

